# day 01

## 프로그래밍 언어(ex. JAVA)

    프로그래밍 언어는 개발자와 운영체제가 소통하기 위한 언어.
		

## 소스코드

    명령어를 작성해 놓은 것.
    개발자와 운영체제가 소통할 것을 글로 작성해 놓은 것.

## 소스파일(.java)

    소스 코드를 작성해 놓은 파일.

## 컴파일

    사람의 언어를 컴퓨터 언어로 바꿔주는 작업.

## 컴파일러

    컴파일을 해주는 프로그램 또는 명령어
    컴파일러는 위 → 아래, 좌 → 우 방향으로 번역.


## 프로그램

    소스코드로 잘 짜여진 틀.

## 콘솔

    개발자와 운영체제가 소통한 결과를 보여주는 창.



## 일반 프로그램

    프로그램
    OS(운영체제) : 하드웨어에 적절한 전기신호를 흘려주는 역할.
    하드웨어 

##  JAVA 프로그램

    JAVA 프로그램
    JVM : JAVA 프로그램을 OS에 맞게 변환해줌.
    OS(운영체제) : 하드웨어에 적절한 전기신호를 흘려주는 역할.
    하드웨어 	

    - 이식성이 좋음.

## JVM(Java Virtual Machine)

    Java 프로그램을 실행해 줌.

## JRE(Java Runtime Environment)

    JVM을 생성하며, 실행할 때 필요한 라이브러리 파일들을 가지고 있음.

## JDK(Java Development Kit)

    JRE 외에 개발에 필요한 도구들을 갖고 있음.
    컴파일 명령어와 실행 명령어를 담고 있음.

## 자바의 기본 구조

	프로젝트
       패키지(소문자로 시작)
			클래스(대문자로 시작)
				메소드(클래스 밑에 소속되어 있으므로 함수로 부르지 않음)
					소스코드


## 출력 메소드

	1. print() : 마지막에 자동으로 줄바꿈되지 않고 아래 문장과 이어서 출력.
	2. println() : 마지막에 자동으로 줄바꿈.
	3. printf() : 	

## 출력 메소드를 사용하는 이유

    데이터를 확인하기 위해서 사용하는 도구.
    오류를 구체화하기 위해 사용하는 도구.
    즉, 출력 매소드는 개발자를 위한 도구.


    A 코드
    B 코드
    C 코드
    D 코드

    오류 발생시 어떤 라인에서 발생했는 지 알 수 없다.

    A 코드
    System.out.println("A")
    B 코드
    System.out.println("B")
    C 코드
    System.out.println("C")
    D 코드
    System.out.println("D")

    C가 콘솔에 출력되었다면, 위에서 아래로 번역되기 때문에 D 코드에 문제가 발생한 것으로 판단된다.

## 변수

	변수는 저장공간.
	
	x	=	10
저장공간의 대입 값
이름		연산자


## 자료형(type) : JAVA는 정적 바인딩

	자료형은 저장공간의 종류

	자료형	type		byte		값
	정수형	byte		1		4, 1, 100 ...
			short		2		5, 1, 290 ...
			int		4		1234, 459238, ... (기본형)
			long		8		1277398L...
	

	실수형	float		4		1.9F, 129.1049F
			double	8		213.1314


	문자형	char		2		'A','0','한'
	문자열	String	가변		"ash", "12803"

## 변수의 선언

		자료형 변수명 = 초기값;
		자료형 변수명;  --> 선언만 하면 garbage value가 들어간다.

		예) int x = 10;
		x라는 이름의 정수형 저장공간이 할당되고 그 안에 10이 들어간다.

## 변수의 초기값

	정수 : 0
	실수 : 0.0
	문자 : ' '
	문자열 : " " , null

## 변수의 사용

   저장공간의 확인 단계
   1단계: 자료형을 확인한다.
   2단계: 대입 연산자를 확인한다.

   int data = 10;   // 저장공간
   data + 9;      // 값
   data = data + 99   // 저장공간, 값

## 변수 선언 시 주의사항

   1. 같은 이름의 변수로 선언할 수 없다.
   2. 초기화를 해준다.
   3. 되도록 선언부에 한꺼번에 선언한다(영역 상단).

## 변수명 주의사항

   1. 문자로 시작해야 한다.
   2. 특수문자를 사용할 수 없다. 단, _는 허용한다.
   3. 소문자로 시작한다.
   4. 공백을 사용할 수 없다.
      good boy
      good_boy: 언더바 표기법
      goodBoy: 카멜 표기법
   5. 되도록 한글을 사용하지 않는다.
   6. 명사로 사용한다.
   7. 뜻이 있는 단어를 사용한다.
   
      a, b, c, d, e, f, ... (X)
      number, num, data, age, name, ... (O)

## 변수를 사용하는 이유

   1. 반복되는 값을 쉽게 관리하기 위해서
   2. 의미 없는 값을 하나의 정보로 만들기 위해서(자료구조)

	
## 상수

	항상 그대로인 수.
	값을 변경할 수 없도록 함.
	
	final 자료형 상수명 = 값;

## 상수를 사용하는 이유

	값에 의미부여를 하기 위함.

## 형변환

	- 자동 형변환
		
		정수 + 정수 = 정수
		정수 + 실수 = 실수
		정수 + 문자 = 정수 ex) A=65
		'A' + 3 = 68
	- 강제 형변환
		(자료형) 값
	ex)	(double)3 = 3.0
		

## 문자열 형변환

	1. 다른 자료형을 문자열로
		문자열과 다른 일반 자료형으로 연결하면 됨.

	2. 문자열을 다른 자료형으로
		일반 자료형은 일반 자료형 끼리만 형변환이 가능.
		문자열 타입은 클래스 타입이므로, 일반 자료형의 클래스 타입의 도움이 필요함.

	Integer.parseInt("")
	Double.parseDouble("")
	String 클래스의 값을 int, double로 바꾸는 형태



## 입력

	커서가 깜박이고 있는 상태가 입력 상태.
	입력하기 전에 출력을 통해 어떤 값을 입력해야 할지 사용자에게 알려줘야 함.

## 입력 클래스

	Scanner 변수명 = new Scanner(System.in);
	자료형				값



## 입력 메소드

	next(() : 사용자가 입력한 문자열 값
		- 사용자가 입력한 값 중 공백 또는 줄바꿈 문자(엔터)를 구분점으로 각 문자열 분리.
		- n번째 문자열은 n번째 next()에 담김.

	nextLine() : 사용자가 입력한 문자열 값
		- 공백 또는 줄바꿈 문자도 모두 값으로 취급하여 입력받음.

## 연산자

		기능이 있는 특수문자

## 연산자의 우선순위

	최우선 연산자 → 단항 연산자 → 산술 연산자 → 쉬프트 연산자
    → 관계 연산자 → 논리 연산자 → 삼항 연산자 → 대입 연산

## 결합성

    하나의 수식에 동일한 연산자가 여러 개 사용되면 알맞은 방향으로 결합되어 연산되는 성질.

## 논리형(boolean)

    참: true
    거짓: false
    초기값: false

    ex)
    boolean(1byte) = true, false
    boolean check = true;

## 조건식

    결과가 참 또는 거짓, 둘 중 하나가 나오는 식이다.


## 관계 연산자

      ==   같다
      !=   같지 않다
      > , <   초과, 미만
      >= , <=   이상, 이하


## 논리 연산자

      && (AND), A && B     두 조건식 모두 참이면 참
      || (OR), A || B      두 조건식 중 하나라도 참이면 참

   
## 단항 연산자

      ! (NOT), !A      조건식이 참이면 거짓으로, 거짓이면 참으로 변경


## 삼항 연산자

      ? :   조건식 ? 참 : 거짓, 조건식이 참이면 참, 거짓이면 거짓
      
      ex)
      int result = 10 > 11 ? 10 : 11;
      
      ※ 한 개의 조건식만 있을 때 사용하는 것이 좋다.

# day02
## 배열 : 저장공간의 나열

	1.
		변수를 여러 개 선언하면 이름도 여러 개 생김. 이 때 각 저장공간을 관리하기 불편함.
		따라서 n칸 배열을 한 번만 선언하면, 저장공간도 n개 생기고, 이름도 한 개이기 때문에
		관리하기 편함.

	2.
		규칙성이 없는 값에 규칙성을 부여하기 위함.		

## 배열의 선언
	자료형[] 배열명 = {값}      // new는 생략된 상태임.
		어떤 값을 넣을지 알 때 사용.

	자료형[] 배열명 = new 자료형[칸 수]; // heap 메모리 : 동적 메모리 영역.
		어떤 값을 넣을지는 모르나, 몇 칸 만들지는 알 때 사용.
		
	자료형[] 배열명 =  null;
		어떤 값을 넣을지도 모르고, 몇 칸 만들지도 모를 때 사용.

		※ new : Heap 메모리에 할당, 초기값으로 자동 초기화. 주소값만 존재하는 영역.
		※ null : 주소의 초기값, 어떤 주소를 넣을지 모를 때 작성하는 값.
		※ JAVA에서 배열은 항상 Heap(동적 메모리)에 할당되기 때문에 메모리 상으로는 동적 배열만 존재.

## 배열의 구조
	
### length
	
	배열을 선언하면 length라는 상수가 선언되고, 해당 배열의 길이가 담김.
	ex) (배열명).length 

### 배열의 사용예시

	int[] arData = new int[5];      // 저장공간
	arData[0] = 120;         // 저장공간
	arData[0] + 9;         // 값
	System.out.println(arData);      // 주소값
	arData[2] = arData[0] + arData[1];   // 저장공간, 값
	System.out.println(arData[5]);      // 오류


### 2차원 배열 

	배열 안에 배열이 있는 구조이기 때문에 값에 접근하기 위해 2번 접근해야 된다.
	1차원 배열을 여러 개 선언하면, 관리하기 어렵다.
	2차원 배열을 한 번만 선언해서 관리한다.

	* 2차원 배열부터는 메모리 낭비가 심하므로 선호하지 않는 편이다.

### 2차원 배열 선언

	자료형[][] 배열명 = {{값} , {값}};
	자료형[][] 배열명 = new 자료형 [행][열];
	자료형[][] 배열명 = null;

### 배열의 차원

	의 ▶ 면 ▶ 행 ▶ 열

## day 03

### 클래스(반)
		공통 요소를 한 번만 선언해놓고 사용하도록 설계한다.
		
	* 타입(자료형)
		클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,
		해당 클래스 타입으로 변수를 선언.

	* 주어
		Class.make("blank");
		클래스가 만든다 공간을

### 클래스 선언
	class (클래스명) {
		필드(변수, 메소드)
	}		
	
### 클래스의 필드 사용
	* 객체화(instance) : 객체(instance variable)를 만드는 작업, 추상적인 개념을 구체화시키는 작업.
		클래스명 객체명 = new 생성자();

	* .(마침표) : 하위 연산자, 멤버 변수 접근 연산자, 닷 연산자, 점 연산자
				주소값 뒤에서만 사용이 가능하며, 해당 주소를 참조하는 명령어.

	* 생성자
		클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 기능이 똑같지만, 메소드가 아님.
		생성자는 리턴 기능이 존재하지 않기 때문(void도 아님).
		
		1. 해당 클래스의 필드를 메모리에 할당한 후 부여된 주소값을 가져옴.
		2. 초기화


### 기본 생성자
	매개 변수가 없는 생성자이며, 클래스 선언 시 컴파일러가 자동으로 작성해줌.
	만약 직접 생성자를 선언하게 되면, 더 이상 컴파일러가 작성해주지 않음.

### this
		필드에 접근한 객체가 누군지 알아야 해당 필드에 접근할 수 있음.
		이 때 접근한 객체가 가지고 있는 필드의 주소값이 this라는 변수에 자동으로 담김.

### 다형성(Polymorphism)
	1. 오버로딩(overloading)
		매개 변수의 개수 혹은 타입이 다르면 동일한 이름의 메소드로 선언할 수 있음.

	2. 오버라이딩(overriding)
		부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의.
		같은 이름의 메소드로 선언하면, 자식 객체로 접근했을 때 가까운 곳에서
		찾기 때문에 자식 필드에서 재정의된 메소드가 사용됨.
		이 때 부모의 메소드를 사용하고 싶다면, 재정의한 메소드 안에서 super로 접근할 수 있음. 

### 배열과 클래스의 차이점.
	배열은 같은 자료형만 담을 수 있으며, 각 방을 번호(index)로 기억해야 함.
	순서가 있어야하는 것 또는 처음부터 끝까지 가져오는 작업이라면 배열에 담는 것이 좋음.
	클래스는 서로 다른 자료형도 담을 수 있으며, 각 값은 전부 이름을 붙여서 필드로 구성.
	원하는 값을 가져오고 싶다면, 클래스로 가져오는 것이 나음.

## day 04 

### 상속(Inheritance)

	1. 기존에 선언된 클래스의 필드를 다른 클래스의 필드로 사용하고자 할 때 사용한다
	2. 여러 클래스 선언 시 필드가 겹치면 공통 필드로 묶고자 할 때 사용한다.
	
### 상속 문법
	* 부모 클래스
	class A {		
		A 필드
	}
	
	* 자식 클래스
	class B extends A {
		(A), B 필드
	}
	
	- 대표적인 명칭
	A : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
	B : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

### super() : 부모 생성자
	자식 클래스 타입의 객체는 부모 필드에 접근할 수 있다. 하지만 자식 생성자만 호출하기 때문에, 자식 필드만 메모리에 할당된다.
	
	그렇기 때문에, B타입의 객체로 A필드인 부모 필드에 접근할 수 없어야 정상이다.

	사실 자식 생성자에서 항상 부모 생성자를 호출하기 때문에 자식 생성자 호출 시 부모와 자식 필드 모두 메모리에 할당된다.
	
	이 때 부모 생성자를 호출하는 방법은 super()를 사용하는 것. 만약 작성하지 않더라고 컴파일러가 자동으로 작성한다.

	만약 직접 super()를 작성한다면, 부모 생성자가 먼저 호출되어야 하기 때문에 영역의 최상단에 작성해야 한다.

### Casting
	모든 자식은 부모 타입을 가지고 있다.
	만약 구현되지 않은 메소드가 있다면 메모리에 올릴 수 없음.

	1. upcasting
		자식 값을 부모 타입으로 형변환
		
		ex)
		부모 객체 = new 자식 생성자();

	2. downcasting
		upcasting된 객체를 다시 자식 타입으로 형변환

		(자식 클래스) upcasting된 객체
	ex)	(double)3  ==> 3.0

	※ 부모 값을 자식 타입으로 형변환 시 오류가 발생한다.	

### 타입 검사(instanceof)
	문법 :	(객체) instanceof (타입)
	1. 같은 자료형이면 true
	2. 다른 자료형이면 false


### Casting을 잘 사용하는 방법
	모든 자식들을 하나의 타입으로 묶을 때 upcasting을 진행한다.

	전달받은 자식 객체가 어떤 타입으로 검사한 뒤 해당 타입으로 downcasting을 진행한다.

	즉, 묶어서 하나의 타입으로 받고, 다시 원래 타입으로 복구하자!

### 접근 권한 제어자(접근자)
	1. default : 다른 패키지에서 접근 불가

	2. public : 모든 곳에서 접근 가능, 만약 클래스 앞에 붙인다면 메인 클래스를 의미.

	3. protected : 다른 패키지에서 접근 불가, 자식은 무조건 접근 가능.
	객체가 반드시 1개만 있어야 할 때, 메소드로 접근하라는 의미. 객체화를 위해 리턴값을 이용하라는 뜻.

	4. private : 다른 클래스에서 (직접) 접근 불가, 메소드로 접근하라는 의미.(getter와 setter 만들기)
		※ private 필드는 getter와 setter를 만들기. (Alt + Shift + S + R)

## day 05

### 추상 클래스
	필드 안에 구현이 안 된 메소드가 선언되어있는 클래스를 추상 클래스라고 함.

	이 때 구현되지 않은 메소드를 추상 메소드라고 부름.

	즉, 추상 클래스에 추상 메소드를 선언할 수 있음.

	이는 반드시 구현해야 하기때문에 "강제성"을 부여할 수 있게 됨.

### 추상 클래스 선언
	abstract class 클래스명 {
		abstract 리턴타입 메소드명(매개변수, ...);
		(일반 메소드도 선언 가능)
	}


### 인터페이스(틀) 
	클래스와는 비슷하지만 다른 문법. 추상 클래스를 고도화시킨 문법, 상수와 추상 메소드만 존재함.

	구현은 지정한 클래스에서 진행하고, 인터페이스를 다른 클래스에 지정할 때에는	implements 키워드를 사용함.

### 추상 클래스와 인터페이스 간의 관계
	인터페이스를 클래스에 바로 지정하면 모든 메소드에 강제성이 부여되기 때문에 전부 다 구현해야 한다. 하지만 일반적인 상황에서는 필요한 메소드를 골라서 재정의함.

	따라서 인터페이스를 직접 지정하지 않고 다른 클래스에 지정한 후 구현해 놓는다면,	강제성이 소멸되고 이로 인해 골라서 재정의할 수 있게 된다.

	이 때 중간에서 강제성을 없애주는 클래스를 추상 클래스로 선언하기로 하며, 추상 클래스 이름 뒤에는 Adapter를 붙여서 목적을 알려준다.


## 내부 클래스(Inner Class)
	모바일 개발에서 많이 사용한다.
	어떤 영역 안에 클래스가 선언되면 내부 클래스라고 함.

### 익명 클래스(Anonymous Inner Class)
	이름이 없는 클래스이며, 구현되지 않은 필드를 구현하기 위해서 일회성으로 생성되는 클래스임.


## day 06

### 함수형 인터페이스(Functional Interface)
	인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 함.
	이 때 @Fucntionalinterface를 인터페이스 위에 작성하여 단 하나의 추상 메소드만 선언하도록 함.
	

### 람다식(Lambda Expression)

### 익명 메소드
	함수형 인터페이스에서는 한 개의 추상 메소드만 존재하기 때문에 구현 시 메소드 이름이 필요없음.	
	람다식은 이름이 없는 메소드로서, 값처럼 사용이 가능하고 당연히 매개변수로도 전달이 가능.
	따라서 람다식을 익명 메소드라고도 부름.

### 람다식 문법
	1. (매개변수 형식 나열, ...) -> 리턴값;
	2. (매개변수 형식 나열, ...) -> {실행할 문장, return 리턴값;};
	3. 매개변수 -> 리턴값;
	4. 매개변수 -> {실행할 문장; return 리턴값;};



### 예외 처리
	에러 : 심각한 오류
	예외 : 덜 심각한 오류

	컴파일 시, 빌드 시, 런타임 시, 오류가 발생하면 제어문 혹은 문법 교정을 통해 막을 수 있지만 아예 막을 수 없는 상황도 발생한다.
	
	컴퓨터에 이상이 생길 정도로 심각한 오류는 에러라고 표현하고 프로그램에 이상이 생긴 것은 예외라고 부른다.

	하지만 정해진 용어는 없으니 보통 "오류"라고 부른다.

	프로그램이 강제 종료되는 것을 막는 게 예외 처리의 목적이다.

### 예외 처리 문법
	
	try{
		오류가 발생할 수 있는 문장;
	}
	catch(예외이름 객체명){
		오류 발생 시 실행할 문장;
	}

	...

	finally{
		(catch에서 잡히지 않은 오류가 있더라도 무조건 실행.)
	}

### 예외 발생
	직접 예외를 발생시키기 위해서는 thorw를 사용해야 하며
	이 때 생성자 호출 전 throw 키워드를 사용한다.
	예) throw new BadWordException();

### 사용자 정의 예외
	기본적으로 제공되는 예외가 아닌 특정 상황에서 직접 예외를 만들어야 한다면, Exception 혹은 RuntimeException을 상속받아서 예외 클래스를 선언해야 한다.
	
	Exception은 컴파일러가 체크하기 때문에 예외처리를 강제로 해야하고, RuntimeException은 컴파일러가 체크하지 않기 때문에 예외처리를 선택할 수 있다.

## day 07

### API(Application Programming Interface)
	개발에 필요한 라이브러리들의 집합.
	선배 개발자들이 만들어놓은 소스코드의 집합체.

	- 내부 API
		JDK 설치 시 제공해주는 기본 API.

	- 외부 API
		선배 개발자들이 개발한 패키지 및 클래스들을 의미함.
		보통 JAR 파일로 배포하며 자바 프로젝트의 build path에 추가하여 사용할 수 있음.
	

### JAR 파일로 배포하기
   	1. 배포할 클래스 또는 패키지 우클릭
	2. Export > JAVA/JAR file 선택 > Next
	3. destination을 원하는 경로로 선택
	4. Export Java source files... 체크
	5. Finish

### JAR 파일을 프로젝트에 추가하기
	1. 배포된 JAR파일을 다운 받기
	2. 프로젝트 우클릭 > Build Path > Configure Build Path
	3. Libraries 탭 클릭 > ClassPath(안되면 ModulePath) 클릭 > Add External JARs
	4. 저장된 경로의 .jar파일을 더블 클릭으로 추가 > Apply and Close

### Object 클래스
	최상위 부모 클래스로서, 모든 클래스는 자동으로 Object를 상속받는다.

	* toString()
		항상 객체명을 출력할 때에는 toString()을 붙여서 출력
		따라서 객체명만 출력메소드에 전달하더라도 toString()의 문자열 값이 출력
		기본적으로 Object에 선언된 toString()은 소속과 필드 주소를 문자열로 리턴.
		실 사용에서는 불필요한 정보이기 때문에, 재정의 후 필드의 정보를 확인하도록 구현.
		실무에서는 클래스 선언 시 각 필드의 초기화 여부를 확인할 때 toString()을 재정의하여 사용.

	* equals()
		주소값을 비교하는 메소드이며 ==과 동일.
		String 클래스에서 equals()를 값 비교로 재정의하여 사용하기 때문에
		문자열 비교는 무조건 equals()로 사용함.
		만약 주소 비교가 아닌 원하는 필드의 비교가 필요하다면 반드시 equals()를 재정의해서 사용.
		
	* hashCode()
		JVM에서 관리하는 중복 없는 값으로, 실제 메모리에 할당되는 주소와 다름.
		※ 컬렉션 프레임워크 챕터에서 재정의 목적을 이해하도록 함.
	
### Wrapper Class
	기본 자료형들의 클래스 타입.
	클래스타입 객체 = new 클래스타입(일반타입의 값);
	클래스타입 객체 = 클래스타입.valueOf(일반타입의 값);
	일반타입 변수 = 객체.000Value();

## day 08

### 알고리즘
	어떤 문제가 발생되었을 떄 해결할 수 있는 절차 혹은 순서.

### 자료구조(저장소)
	의미 없는 데이터를 하나의 정보로 만들어주는 알고리즘들의 집합.
	저장소의 종류에 대해 알아보고 목적과 상황에 맞게 골라 사용!

### Collection Framework(컬렉션 프레임워크)
	많은 데이터를 쉽고 효과적으로 관리할 수 있는 자료구조 클래스들의 집합.
	* 인터페이스 간에도 상속이 가능.(인터페이스끼리만)

### List extends Collection
	List는 인터페이스. List를 구현한 클래스들은 아래와 같음.
	
	1. Vector : 용량 관리, 보안성 강화 - 임베디드에서나 쓸 법함.
	2. LinkedList : 넣을 때는 빠르지만 원하는 위치의 데이터를 가져오는 것이 상대적으로 느림. 
	3. ArrayList(중요) : 인덱스로 데이터를 관리함. 컬렉션 클래스 중 실무에서 가장 많이 사용되는 클래스.
			     배열의 특징인 인덱스를 이용하여 값을 저장하고 관리함.(몇 개 담을 지 모를 때 사용.)

	※ 배열과 ArrayList의 차이
		배열은 길이에 제한을 두어야 할 때 자주 사용되고,
		ArrayList는 몇 개의 데이터가 들어오는지 알 수 없을 때 사용함.

## day 09

### Set(집합)
	Set은 인터페이스이다. Set을 지정받아 구현한 대표적인 클래스는 HashSet.
	List와 마찬가지로 Collection 인터페이스를 상속받은 인터페이스.

### HashSet
	집합에서 중복되는 원소를 포함할 수 없는 것처럼 HashSet 이라는 자료구조는 중복된 값을 무시.
	저장된 값들은 순서가 없기 때문에, 저장된 값들은 가져다 쓸 수 없음.
	값의 유무 검사에 특화되어 있는 자료구조이며, 해시코드를 사용하여 검사하기 때문에
	상대적으로 속도가 빠름.

### Iterator
	순서가 없는 객체에 순서를 부여하거나, 순서가 있어도 Iterator 방식의 순서로 변경할 때 사용.
	이 때 해당 객채에 iterator() 메소드를 사용하고, 이 메소드의 리턴 타입은 Iterator 타입.
	hasNext()를 사용하면 다음 값이 있는 검사할 수 있고 없다면 false.
	next()를 사용하면 다음 값을 가져올 수 있음.

### Map
	Set과 Collection 2개의 자료구조를 하나로 합친 자료구조.
	List와 Set 처럼 Colleciton을 상속받지 않았고, 독립적인 자료구조.
	
### HashMap(서버 간 데이터 교환)
	Key와 Value, 한 쌍으로 지정되며, 검색의 목적을 가지고 있음.
	Key에 중복된 값을 넣으면, Value가 최근 값으로 수정되고,
	중복되지 않은 값을 넣으면 새롭게 추가됨. 단, Value는 중복을 허용.

## day 10

### 프로그램
	실행이 안된 상태

### 프로세스
	실행중인 프로그램

### Thread
	프로세스 내의 작업 처리 경로.

	- Single Thread
		처리 경로를 한개만 가지고있기 때문에 직렬적.
		한 번에 하나씩 처리하기 때문에 상대적으로 비효율적.
		하지만 하나의 작업에 문제가 발생하더라도 다른 작업 시작되지 않았으므로
		다른 작업에는 문제가 발생하지 않음. 따라서 안정성 보장.
		멀티 쓰레드에 비해 설계가 쉬움.
	
	- Multi Thread
		하나의 프로세스를 동시에 처리하는 것처럼 보이지만 사실은 매우 짧은 단위로 분할해서 차례로 처리.
		여러개의 처리 경로를 가질 수 있도록 하며, 동시 작업 가능해짐.
		하나의 쓰레드 문제 발생 시 모든 쓰레드에 문제가 발생하게 됨.
		멀티 쓰레드로 설계한다면, 처리량 증가, 효율성 증가, 처리비용 감소의 장점이 있기 때문에
		이러한 단점을 감수하고 설계하는 편임.

### Multi Thread 구현 방법.
	핵심 : run() 메소드 재정의.
	1. Thread 클래스 상속
	2. Runnable 인터페이스 구현
	


### 동기화(Synchronized)
	muteX 는 run이 재정의한 객체
	하나의 쓰레드가 자원에 접근 중일 때 다른 쓰레드가 동시에 같은 자원을 접근하지 못하게 막는 것.
	즉, 자원 공유 문제를 해결할 수 있고 각 쓰레드를 제어해야 할 때에도 자주 사용.

	- 블록
		synchronize{
			...
		}

		영역 안에 동기화가 걸림.
		
	- 키워드
		메소드

## day 11

### 파일 입출력
	Stream이라는 연결통로를 통해 원본 데이터가 알맞은 인코딩 방식으로 전송됨.
	byte 단위로 입출력되기 때문에 개별처리이며, 상세 연산이 필요하지 않다면 Buffer를 사용한 입출력을 권장함. Buffer를 사용하면 일괄처리가 가능해짐.

### Writer(출력)
	* BufferedWriter
		버퍼를 사용하는 출력 클래스

	* FileWriter
		전달한 경로의 파일을 출력의 목적으로 열어줌.
		전달한 경로에 파일이 없다면, 새롭게 만든 후 열어줌.

### Reader(입력)
	* BufferedReader
		버퍼를 사용하는 입력 클래스

	* FileWriter
		전달한 경로의 파일을 입력의 목적으로 열어줌.
		전달한 경로에 파일이 없다면, FileNotFoundException이 발생.

### File
	전달한 경로에 있는 파일의 정보를 담는 타입.
	디렉터리 생성, 해당 경로의 전체 파일 목록, 파일 삭제 등.

